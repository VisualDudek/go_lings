#separator:Pipe
#html:true
#tags:Go Slices
#deck:go_slices

What is a slice in Go and how does it differ from an array?|A slice is a dynamically-sized, flexible view into an array's elements. Unlike arrays (fixed size), slices have three components: pointer (to underlying array), length (current elements), and capacity (max elements before reallocation). Slices are reference types to the underlying array.

What does `append()` return in Go, and why is it necessary to assign the result?|`append()` returns a new slice that may point to a different underlying array (if capacity exceeded). You must assign the return value because if the slice grows beyond capacity, `append()` allocates a new array and returns a slice pointing to it. The original variable won't reflect this change without reassignment.

Why does calling `append()` inside a function NOT modify the caller's slice?|Slices are passed by value (the header: pointer, length, capacity is copied). When `append()` reallocates (exceeds capacity), the function's local slice header is updated to point to the new array, but the caller's slice header remains unchanged. To modify the caller's slice, the function must return the new slice.

When you reslice with `s[:2]`, what happens to the capacity of the new slice?|The capacity of the resliced slice becomes the remaining capacity of the original slice from the starting point. For example, if `s := []int{1,2,3,4,5}` (len=5, cap=5), then `sub := s[2:]` has cap=3 (5-2), not cap=0.

What is the "full slice expression" and how does it protect against append overwriting?|The full slice expression is `s[low:high:max]`, which sets a custom capacity limit for the resliced slice. Example: `s[:2:2]` creates a slice with len=2 and cap=2, preventing `append()` from overwriting elements beyond the slice. Without it, a reslice like `s[:2]` has cap=5, so `append()` would write to index 2 (the 3rd element).

What is the difference between `len()` and `cap()` for slices?|`len()` returns the number of elements currently in the slice. `cap()` returns the total number of elements in the underlying array from the slice's starting position. A newly resliced portion may have length < capacity.

When you assign `x := append(s, []int{4,5,6}...)`, what does the `...` operator do?|The `...` operator unpacks the slice `[]int{4,5,6}` into individual arguments. Without it, you'd be appending the slice itself as a single element. With `...`, it appends each element: `append(s, 4, 5, 6)`.

What is the "slice header" and what does it contain?|The slice header is the metadata struct that represents a slice in memory. It contains three fields: a pointer to the underlying array's first element, the length (number of accessible elements), and the capacity (size of underlying array from pointer position).

When you create a slice with `make([]int, 5)`, what are the length and capacity?|Length is 5 and capacity is 5. The slice is initialized with 5 zero-value elements (0 for int). Both length and capacity default to the same value when only one argument is provided.

What happens when you `append()` to a slice created with `make([]int, 5)`?|The `append()` adds to index 5 (beyond the current length), making the result have length 6 and capacity >= 6 (likely 10 due to Go's growth strategy). The zero-initialized elements (indices 0-4) remain unchanged.

How does Go's slice growth strategy work when capacity is exceeded?|When appending beyond capacity, Go allocates a new underlying array. The growth follows roughly: if capacity < 1024, new capacity = current capacity * 2. If capacity >= 1024, new capacity â‰ˆ current capacity * 1.25. All existing elements are copied to the new array.

What is the pitfall when you modify a resliced slice with `append()`?|If the reslice shares capacity with the original slice, `append()` can overwrite elements in the original slice beyond the reslice's length. Example: `s := []int{1,2,3,4,5}; sub := s[:2]; append(sub, 100)` overwrites index 2 in `s`, resulting in `s = [1,2,100,4,5]`.

How do you safely reslice without risk of append overwriting the original?|Use the full slice expression: `sub := s[:2:2]` instead of `sub := s[:2]`. This sets the capacity of `sub` to 2, so `append()` will reallocate and create a new underlying array rather than overwriting `s`.

What does `clear(s)` do to a slice?|`clear(s)` sets all elements in the slice to their zero value (0 for int, empty string for string, nil for pointers, etc.). It does NOT change the length or capacity of the slice; only modifies the elements.

In a `for range` loop over a slice, are you iterating over the value or a copy of the value?|You are iterating over a copy. `for _, v := range s { }` gives you a copy of each element, not a reference. Modifying `v` does not modify the original slice element. To modify elements, you must iterate over indices: `for i := range s { s[i] = newValue }`.

How do you safely iterate over a slice of slices (2D slice)?|Use `for _, row := range matrix { }` to get each inner slice, then `for _, elem := range row { }` for elements. Each `row` is a reference to the inner slice (not a copy), so you can modify elements via `row[i] = value`.

What is the memory overhead of a slice variable that contains no elements?|A nil slice `var s []int` has zero overhead beyond the slice header (pointer, length, capacity metadata). It is not memory-intensive; the header itself is small (24 bytes on 64-bit systems).

When you append to a nil slice, what happens?|`append(nil, value)` returns a new slice with length=1, capacity>=1, and the value at index 0. The nil slice itself is not modified; you must assign the result: `s = append(s, value)`.

What is the difference between a nil slice and an empty slice `[]int{}`?|Both have length=0, but a nil slice has a nil pointer and capacity=0, while `[]int{}` is an allocated empty slice with a pointer to allocated memory. Functionally, both behave similarly; the distinction is rarely critical.

Why does this code cause inefficiency: `for i := 0; i < 10; i++ { s = append(s, i) }`?|Each `append()` beyond capacity causes reallocation and copying of all elements. With 10 iterations starting from nil, you may reallocate 4-5 times (capacities: 1, 2, 4, 8). This is O(n) work instead of O(1) if you used `make([]int, 10)` upfront.

How do you efficiently pre-allocate a slice when you know the final size?|Use `s := make([]int, 0, capacity)` to create a slice with length=0 and capacity=capacity. Then `append()` will not reallocate until you exceed the capacity. Alternatively, create with the exact size: `s := make([]int, size)` and assign via index.

What is the "slice data pointer" and how do you access it?|The slice data pointer is the memory address of the first element in the underlying array. Access it with `unsafe.SliceData(s)` (returns `*T`) or `&s[0]`. Two slices pointing to the same underlying array will have the same data pointer.

When two slices share the same underlying array, can modifications via one slice be seen by the other?|Yes, if they overlap in the underlying array's index range. Modifying `s[i]` affects both slices if both reference index `i`. This is why reslicing and appending can cause unexpected mutations.

What is the risk of `s2 := append(s1, 4)` when both `s1` and `s2` are used afterward?|If `s1` has capacity for the append, the new element is written to the underlying array that both slices share. `s1` and `s2` may point to the same array with different lengths. Modifications via `s2[0]` affect `s1[0]`, causing unexpected mutations if you thought they were independent.

How do you create a 2D slice (slice of slices) and ensure each row is properly allocated?|Create with `s := make([][]int, rows)`, then allocate each row: `for i := range s { s[i] = make([]int, cols) }`. Without this, the inner slices are nil and cannot be indexed.

What is the idiomatic way to iterate over slice indices and values together in Go?|Use `for i, v := range s { }` to get both index `i` and a copy of the value `v`. Remember that `v` is a copy; to modify elements, use `s[i] = newValue`.

How do you iterate over only the indices of a slice without caring about values?|Use `for i := range s { }` (underscore is implicit) or explicitly `for i := range s { _ = i }` if you want to use the index. This is more efficient than `for i, _ := range s`.

What does `s[start:stop]` syntax do, and what are the bounds?|It creates a reslice from index `start` (inclusive) to index `stop` (exclusive). Valid indices are 0 <= start <= stop <= len(s). Panics if bounds are out of range. Example: `s[1:3]` includes indices 1 and 2, not 3.

What does `s[:stop]` and `s[start:]` do?|`s[:stop]` is equivalent to `s[0:stop]` (from start to stop). `s[start:]` is equivalent to `s[start:len(s)]` (from start to end). Both are convenient shorthands.

What is `s[:]` and when is it useful?|`s[:]` creates a full reslice from index 0 to len(s), with the same underlying array and capacity. It is useful when you need a "new" slice variable that shares the same data but is a fresh header (rarely needed in practice).

Can you have a slice with length > capacity?|No, length must always be <= capacity. If you try to create such a slice manually, Go will panic or the behavior is undefined. The invariant is enforced by the language.

What happens if you try to access `s[len(s)]` on a slice?|It panics with an "out of range" error. Valid indices are 0 to len(s)-1. This is a runtime panic, not a compile-time error.

How do you convert an array to a slice?|Use the slice syntax: `arr := [3]int{1, 2, 3}; s := arr[:]`. This creates a slice that points to the array's elements. Modifications via the slice affect the original array.

What is the difference between modifying a slice element via an array vs. via the slice derived from the array?|If `s := arr[:]` and you do `s[0] = 10`, it modifies `arr[0]` because both reference the same memory. This is expected since the slice points to the array's elements.

When you pass a slice to a function, what exactly is passed?|The slice header (pointer, length, capacity) is copied by value. The underlying array is NOT copied; the function receives a reference (via the pointer) to the same array. This means the function can modify elements, but cannot grow the caller's slice via append (without returning it).

What is the function signature for `append()`, and what types can it accept?|`func append(slice []T, elems ...T) []T`. It accepts a slice of type T and variadic elements of type T, returning a new slice. You can also append another slice using the unpacking operator: `append(s1, s2...)`.

What does `copy(dst, src)` do, and what does it return?|`copy(dst, src)` copies elements from `src` to `dst` (up to the minimum of their lengths) and returns the number of elements copied. It does NOT grow `dst`; if `dst` is smaller, only the first len(dst) elements are copied from `src`.

How do you clone a slice to create an independent copy?|Use `newSlice := make([]T, len(s)); copy(newSlice, s)` or `newSlice := append([]T{}, s...)`. The first is more explicit and efficient.

What is the difference between `s = append(s, x)` and `append(s, x)` without assignment?|`append(s, x)` returns a new slice (or reuses if capacity permits), but without assignment, the result is discarded and `s` is unchanged. You must assign: `s = append(s, x)` to update `s`.

What is a potential memory leak when using slices?|If a slice holds a reference to elements (via a pointer to the underlying array) and the slice is kept alive longer than needed, the entire underlying array is kept in memory, even if only a small portion is used. Reslicing a large array and storing the slice can prevent GC of the original array.

How can you break the reference between a slice and its underlying array?|Copy the elements to a new slice via `copy()` or re-slice and copy: `newSlice := make([]T, len(s)); copy(newSlice, s)`. This allows the original array to be garbage collected if the original slice goes out of scope.

What is the behavior of `append()` when the capacity is exactly sufficient (cap == len)?|`append()` checks if capacity > length. If cap == len, there is no room, so it reallocates, typically doubling the capacity (or applying the growth formula). The new slice points to the new array.

What is the time complexity of appending N elements to a slice starting from nil?|O(N log N) due to reallocations. Each reallocation doubles the capacity, so you have ~log(N) reallocations, and each reallocation copies the previous elements (O(N) in total across all reallocations, not per append).

Actually, what is the time complexity of appending N elements to a pre-allocated slice with sufficient capacity?|O(N), constant time per append since no reallocation occurs.

What is the time complexity of reslicing a slice?|O(1), constant time. Reslicing just creates a new header pointing to the same underlying array with adjusted pointer, length, and capacity.

What does the `range` keyword do when iterating over a slice?|It iterates over consecutive indices of the slice in order, from 0 to len(s)-1. Each iteration yields the index (optional) and a copy of the value at that index.

What is the difference between `for i, v := range s` and `for i := range s; _ = s[i]`?|The first gives you both index and value (copy) in one expression. The second iterates over indices but requires manual access to values. Both iterate in the same order, but the first is more idiomatic.

Can you modify the loop variable in a `for range` to affect the original slice?|No, modifying the loop variable `v` does not affect the original slice because `v` is a copy of the element. You must modify via index: `s[i] = newValue`.

What happens if you remove an element from a slice while iterating over it?|Removing an element shifts subsequent elements down in the array, but since you're iterating with pre-computed indices (or a copy of indices), skipping may occur or you may access wrong elements. It's a logic bug; avoid removing during iteration or use a filter/build pattern instead.

What is the idiomatic way to filter a slice (keep elements that match a condition)?|Use a loop to build a new slice: `var filtered []T; for _, v := range s { if condition(v) { filtered = append(filtered, v) } }`. Or pre-allocate if possible: `filtered := make([]T, 0, len(s))` to avoid reallocation.

How do you reverse a slice in Go?|Iterate from both ends, swapping: `for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 { s[i], s[j] = s[j], s[i] }`. There's no built-in reverse function; you must implement it or use `slices.Reverse()` from the standard library (Go 1.21+).

What does `slices.Contains(s, v)` do?|It checks if the value `v` exists in the slice `s` and returns a boolean. It iterates through the slice linearly, so it's O(N). Requires `import "slices"` (Go 1.18+).

What does `slices.Index(s, v)` do?|It returns the index of the first occurrence of `v` in the slice, or -1 if not found. Similar to `strings.Index()`, but for slices. O(N) linear search.

What does `slices.Insert(s, i, v...)` do?|It inserts one or more values `v...` at index `i` in the slice and returns a new slice. Elements at and after index `i` are shifted right. The original slice is not modified; you must assign the result.

What does `slices.Delete(s, i, j)` do?|It removes elements from index `i` (inclusive) to `j` (exclusive) and returns a new slice. Elements at and after `j` are shifted left. Similar to `s = append(s[:i], s[j:]...)`.

When should you use `strings.Join()` with a slice of strings?|When you want to concatenate multiple strings with a separator (e.g., `strings.Join([]string{"a", "b", "c"}, " ")` produces `"a b c"`). It's more efficient than repeated `+` concatenation.

What is the Go idiom for initializing an empty slice vs. a nil slice for JSON marshaling?|For JSON output, prefer `[]T{}` over `nil` if you want an empty JSON array `[]` instead of `null`. Many libraries treat nil slices as `null` in JSON.

What does `unsafe.SliceData(s)` return?|It returns a pointer to the first element of the slice's underlying array (`*T`). It is unsafe and rarely needed; use in performance-critical code or to interop with C code.

What does `unsafe.Pointer(&s[0])` return, and why might you use it?|It returns the memory address of the first element as an unsafe pointer. Use it to inspect the underlying array's address or for low-level memory manipulation. It panics if the slice is empty (no element to take address of).

What is the difference between `unsafe.Pointer(&s[0])` and `unsafe.SliceData(s)`?|`&s[0]` panics if `s` is empty; `SliceData()` does not. `SliceData()` is the safer and recommended way to get the array pointer.

How do you convert a slice to an array in Go?|Use slice-to-array conversion (Go 1.20+): `arr := [3]int(s)` if `len(s) == 3`. Alternatively, copy elements: `var arr [3]int; copy(arr[:], s)`. Direct conversion requires the slice length to match the array length at compile time or panics at runtime.

What is the advantage of using a pointer to a slice as a function parameter?|If you pass `*[]T`, the function can modify the slice header (length, capacity) and be seen by the caller. However, this is rare; usually you return the modified slice instead, which is clearer.

Can you pass a slice as a variadic argument?|Yes, use the unpacking operator: `func foo(args ...int) { }; foo(s...)` unpacks `s` into individual arguments. Without `...`, you'd be passing the slice itself as one argument.

What is the gotcha with slicing a large array and keeping the slice alive?|The small slice holds a reference to the entire large array via the slice header's pointer. Even if only a small portion is used, the entire array is kept in memory and cannot be garbage collected.

How do you avoid this gotcha?|Copy the small slice to a new, independent allocation: `newSlice := make([]T, len(s)); copy(newSlice, s)`. Now the large array can be GC'd.

What is the initialization order when you use a composite literal with a slice?|`[]int{1, 2, 3}` creates a slice, allocates an underlying array, initializes it with the values, and returns the slice. This is equivalent to: `arr := [3]int{1, 2, 3}; s := arr[:]`.

What is a common mistake when creating a slice of pointers?|Forgetting to allocate the pointed-to values. Example: `s := make([]*int, 5)` creates a slice of 5 nil pointers, not 5 ints. You must allocate each: `for i := range s { v := 0; s[i] = &v }` (or in a loop if you want unique pointers).

What is the behavior of `len()` and `cap()` on a nil slice?|Both return 0. A nil slice has no underlying array, so it has zero length and zero capacity.

Can you index a nil slice?|No, indexing a nil slice panics: `var s []int; _ = s[0]` panics with "index out of range". Always check for nil or empty before indexing.

What is the best practice for checking if a slice is empty?|Use `len(s) == 0` rather than `s == nil`. This works for both nil and non-nil empty slices and is more idiomatic.

Can you compare two slices with `==`?|No, slices are not comparable with `==` (except against `nil`). You must compare elements manually: `func equal(s1, s2 []int) bool { if len(s1) != len(s2) { return false }; for i := range s1 { if s1[i] != s2[i] { return false } }; return true }`.

How do you deep-copy a 2D slice (slice of slices)?|Allocate the outer slice, then allocate and copy each inner slice: `result := make([][]T, len(s)); for i := range s { result[i] = make([]T, len(s[i])); copy(result[i], s[i]) }`.

What is the memory layout of a slice on a 64-bit system?|A slice header is 24 bytes: 8 bytes for the pointer to the underlying array, 8 bytes for the length, and 8 bytes for the capacity. This is fixed regardless of the element type.

What happens if you use a negative index when slicing?|Go does NOT support negative indices (unlike Python). `s[-1]` causes a compile-time or runtime error depending on context. Always use positive indices 0 to len(s)-1.

How do slices interact with the garbage collector?|If a slice is the only reference to the underlying array, the array can be GC'd when the slice goes out of scope. If the slice is kept alive (stored in a global or returned), the array is also kept alive.

What is the interaction between slices and concurrency?|Slices are not thread-safe. If multiple goroutines access the same slice's underlying array, you must synchronize with mutexes or channels. Appending is not atomic and can cause data races.

Is it safe for two goroutines to read from the same slice concurrently?|Yes, reading (indexing, len, cap) is safe. Writing (append, assignment) or concurrent reads/writes require synchronization. Multiple goroutines can safely read the same underlying array concurrently.

What does `make([]T, len, cap)` do vs. `make([]T, len)`?|Both create a slice with length `len`. The first variant sets capacity to `cap`, allocating more space for future appends without reallocation. The second sets capacity = length.

What is the typical use case for `make([]T, len, cap)` where cap > len?|Pre-allocate when you know the maximum size in advance. Example: `s := make([]int, 0, 100)` creates an empty slice with capacity 100, allowing 100 appends before reallocation. Then append as needed: `s = append(s, value)`.

What is the performance implication of repeated small appends vs. pre-allocation?|Repeated small appends cause multiple reallocations and copying, which is O(N log N). Pre-allocation is O(N) because no reallocation occurs. For large N, pre-allocation is significantly faster.

How do you decide whether to use arrays or slices?|Use arrays when size is known at compile time (fixed). Use slices when size is dynamic or unknown. Slices are more flexible and idiomatic in Go.

What is the interaction between slices and the `bytes` package?|`bytes.Buffer` internally uses a slice and grows dynamically. You can convert between `[]byte` and strings for efficient manipulation.

What are some gotchas with string slicing?|Strings are immutable, so you cannot slice and modify a string. Slicing a string returns a new string, not a reference. Indices are byte offsets, not rune indices, so multi-byte UTF-8 characters can be sliced incorrectly.
