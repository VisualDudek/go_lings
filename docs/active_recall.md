**Situation**
You are creating Anki flashcards to master programming concepts through spaced repetition and active recall. Programming knowledge requires both conceptual understanding and practical application, making it essential to design flashcards that test both theoretical knowledge and hands-on problem-solving abilities.

**Task**
The assistant should generate comprehensive instructions for creating effective Anki flashcards specifically designed for programming topics. The instructions must incorporate evidence-based active recall techniques optimized for technical learning.

**Objective**
Enable efficient long-term retention of programming concepts, syntax, patterns, and problem-solving approaches through scientifically-proven memory techniques that minimize passive recognition and maximize active retrieval.

**Knowledge**

Core Active Recall Principles for Programming Flashcards:

1. **Minimum Information Principle**: Break complex programming concepts into atomic, single-focused cards. Each card should test one specific piece of knowledge rather than multiple concepts simultaneously.

2. **Cloze Deletion for Syntax**: Use cloze deletions (fill-in-the-blank format) for memorizing syntax, function signatures, and code patterns. This forces active reconstruction rather than passive recognition.

3. **Code Output Prediction**: Create cards showing code snippets where you must predict the output or behavior. This tests understanding of execution flow and logic.

4. **Error Identification**: Present code with intentional bugs or issues and require identification of the problem. This develops debugging skills and deep understanding.

5. **Concept-to-Implementation**: Ask "How would you implement X?" rather than "What is X?" to practice translating knowledge into code.

6. **Reverse Cards**: Create bidirectional cards where appropriate (e.g., "What does this code do?" and "Write code that does X").

**Instructions for Creating Programming Flashcards**

The assistant should structure flashcard creation guidance as follows:

1. **Card Types to Use**:
   - Cloze deletion cards for syntax and definitions
   - Basic Q&A cards for conceptual understanding
   - Code snippet cards for practical application
   - Error detection cards for debugging practice
   - Implementation challenge cards for problem-solving

2. **Syntax and Language Features**:
   - Create cloze cards with actual code examples, not abstract descriptions
   - Include the programming language name in tags for multi-language learners
   - Test both the syntax structure and when to use specific features
   - Example format: "In Python, to create a list comprehension: `[{{c1::expression}} for {{c2::item}} in {{c3::iterable}}]`"

3. **Conceptual Understanding**:
   - Frame questions to require explanation in your own words
   - Ask "why" and "when" questions, not just "what"
   - Connect concepts to practical use cases
   - Example: "When should you use a hash map instead of an array, and why?"

4. **Code Reading and Prediction**:
   - Show 3-8 lines of code and ask for output or behavior
   - Include edge cases and tricky scenarios
   - Test understanding of operator precedence, scope, and execution order
   - Keep code snippets short enough to mentally execute

5. **Implementation Practice**:
   - Phrase as specific, constrained problems
   - Include input/output examples
   - Specify constraints (time/space complexity, allowed methods)
   - Example: "Write a function that reverses a string in-place without using built-in reverse methods"

6. **Best Practices and Patterns**:
   - Create cards for design patterns with code examples
   - Test recognition of code smells and refactoring opportunities
   - Include idiomatic ways to solve common problems in specific languages

7. **Avoid These Common Mistakes**:
   - Don't create overly broad cards covering multiple concepts
   - Don't use vague questions like "Explain object-oriented programming"
   - Don't include long code blocks that require scrolling
   - Don't test trivial information that can be quickly looked up
   - Don't create cards without context or practical application

8. **Organization and Tagging Strategy**:
   - Tag by programming language, topic, difficulty level, and concept category
   - Use hierarchical tags (e.g., "Python::DataStructures::Lists")
   - Create separate decks for different languages or major topic areas
   - Mark cards that test fundamental concepts vs. advanced applications

9. **Optimal Review Approach**:
   - When reviewing code output cards, mentally trace execution before revealing answer
   - For implementation cards, write actual code before checking the answer
   - If you get a card wrong, immediately create related cards testing the gaps in understanding
   - Suspend cards for syntax that you've fully internalized and can reference quickly in documentation

10. **Progressive Difficulty**:
    - Start with basic syntax and simple concepts
    - Progress to combining multiple concepts in single problems
    - Eventually create cards that mirror real-world coding scenarios
    - Regularly add cards based on mistakes made in actual coding practice
